<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>讯飞实时语音转写</title>
<style>
  body { font-family: sans-serif; max-width: 700px; margin: 40px auto; padding: 0 20px; }
  button { padding: 10px 24px; font-size: 16px; cursor: pointer; }
  #interim { color: #999; min-height: 24px; margin-top: 16px; }
  #final { margin-top: 8px; line-height: 1.8; white-space: pre-wrap; }
  #status { font-size: 13px; color: #666; margin-top: 8px; }
</style>
</head>
<body>
<h2>讯飞实时语音转写</h2>
<p>架构：浏览器 → 后端生成签名 URL → 直连讯飞 WebSocket</p>
<button id="btn">开始录音</button>
<div id="status">就绪</div>
<div id="interim"></div>
<div id="final"></div>

<script>
const SERVER = 'http://localhost:3000'
let ws, audioCtx, processor, stream, recording = false
// 讯飞按 sid 拼接多段结果
const sentences = {}

document.getElementById('btn').onclick = () => recording ? stop() : start()

async function start() {
  setStatus('获取签名 URL...')
  const { wsUrl, error } = await fetch(`${SERVER}/token/xunfei`, { method: 'POST' }).then(r => r.json())
  if (error) return setStatus('错误: ' + error)

  ws = new WebSocket(wsUrl)
  ws.binaryType = 'arraybuffer'

  ws.onopen = async () => {
    // 发送开始帧
    ws.send(JSON.stringify({
      common: { app_id: '' }, // appId 已在 URL 签名中
      business: { language: 'zh_cn', domain: 'iat', accent: 'mandarin', vad_eos: 3000 },
      data: { status: 0, format: 'audio/L16;rate=16000', encoding: 'raw', audio: '' },
    }))
    setStatus('已连接，录音中...')
    await startAudio()
  }

  ws.onmessage = (e) => {
    const d = JSON.parse(e.data)
    if (d.code !== 0) return setStatus(`错误 ${d.code}: ${d.message}`)

    const result = d.data?.result
    if (!result) return

    // 拼接当前句子（讯飞按 ws 序号分段）
    const sid = d.sid
    if (!sentences[sid]) sentences[sid] = {}
    result.ws?.forEach(w => {
      const idx = w.bg
      sentences[sid][idx] = w.cw?.[0]?.w || ''
    })

    const text = Object.keys(sentences[sid]).sort((a, b) => a - b)
      .map(k => sentences[sid][k]).join('')

    if (result.ls) {
      // 最后一帧，移入 final
      document.getElementById('final').textContent += text + '\n'
      document.getElementById('interim').textContent = ''
      delete sentences[sid]
    } else {
      document.getElementById('interim').textContent = text
    }
  }

  ws.onclose = () => setStatus('连接已关闭')
  ws.onerror = () => setStatus('WebSocket 错误')

  recording = true
  document.getElementById('btn').textContent = '停止录音'
}

async function startAudio() {
  stream = await navigator.mediaDevices.getUserMedia({ audio: true })
  audioCtx = new AudioContext({ sampleRate: 16000 })
  const source = audioCtx.createMediaStreamSource(stream)
  processor = audioCtx.createScriptProcessor(4096, 1, 1)
  source.connect(processor)
  processor.connect(audioCtx.destination)
  processor.onaudioprocess = (e) => {
    if (ws.readyState !== WebSocket.OPEN) return
    const f32 = e.inputBuffer.getChannelData(0)
    const i16 = new Int16Array(f32.length)
    for (let i = 0; i < f32.length; i++) i16[i] = Math.max(-32768, Math.min(32767, f32[i] * 32768))
    // 讯飞要求 base64 编码的音频放在 JSON data 帧里
    const b64 = btoa(String.fromCharCode(...new Uint8Array(i16.buffer)))
    ws.send(JSON.stringify({ data: { status: 1, format: 'audio/L16;rate=16000', encoding: 'raw', audio: b64 } }))
  }
}

function stop() {
  processor?.disconnect()
  stream?.getTracks().forEach(t => t.stop())
  audioCtx?.close()
  // 发送结束帧
  if (ws?.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ data: { status: 2, format: 'audio/L16;rate=16000', encoding: 'raw', audio: '' } }))
  }
  recording = false
  document.getElementById('btn').textContent = '开始录音'
  setStatus('已停止')
}

function setStatus(msg) { document.getElementById('status').textContent = msg }
</script>
</body>
</html>
